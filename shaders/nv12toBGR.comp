#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, r8) uniform readonly image2D yPlane;
layout(set = 0, binding = 1, rg8) uniform readonly image2D uvPlane;
layout(set = 0, binding = 2, rgba8) uniform writeonly image2D bgrOutput;

layout(push_constant) uniform PushConstants {
    ivec2 rgbaSize;
    ivec2 uvSize;
    int colorSpace;
    int colorRange;
} pushC;

struct RgbCoefficients {
    vec3 r;
    vec3 g;
    vec3 b;
};

RgbCoefficients getCoefficients(int space)
{
    if (space == 0)
    {
        // BT.601
        return RgbCoefficients(
            vec3(1.164383, 0.000000, 1.596027),
            vec3(1.164383, -0.391762, -0.812968),
            vec3(1.164383, 2.017232, 0.000000));
    }
    else if (space == 2)
    {
        // BT.2020
        return RgbCoefficients(
            vec3(1.164383, 0.000000, 1.678674),
            vec3(1.164383, -0.187326, -0.650424),
            vec3(1.164383, 2.141772, 0.000000));
    }
    // BT.709 (default)
    return RgbCoefficients(
        vec3(1.164383, 0.000000, 1.792741),
        vec3(1.164383, -0.213249, -0.532909),
        vec3(1.164383, 2.112402, 0.000000));
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= pushC.rgbaSize.x || pixel.y >= pushC.rgbaSize.y)
    {
        return;
    }

    // Read Y value (normalized 0-1)
    float yNorm = imageLoad(yPlane, pixel).r;
    
    // Read UV values (shared between 2x2 pixels, normalized 0-1)
    ivec2 uvCoord = pixel / 2;
    vec2 uvNorm = imageLoad(uvPlane, uvCoord).rg;
    
    // Convert to unnormalized values
    float Y, U, V;
    
    if (pushC.colorRange == 1)
    {
        // Full range
        Y = yNorm * 255.0;
        U = uvNorm.r * 255.0 - 128.0;
        V = uvNorm.g * 255.0 - 128.0;
    }
    else
    {
        // Limited range (default)
        Y = max(0.0, yNorm * 255.0 - 16.0);
        U = uvNorm.r * 255.0 - 128.0;
        V = uvNorm.g * 255.0 - 128.0;
    }
    
    // Get coefficients for color space
    RgbCoefficients coeffs = getCoefficients(pushC.colorSpace);
    
    // Convert YUV to RGB
    float r, g, b;
    
    if (pushC.colorRange == 1)
    {
        // Full range - use coefficients without 1.164383 factor
        if (pushC.colorSpace == 0)
        {
            // BT.601 full range
            r = Y + 1.402 * V;
            g = Y - 0.344136 * U - 0.714136 * V;
            b = Y + 1.772 * U;
        }
        else if (pushC.colorSpace == 2)
        {
            // BT.2020 full range
            r = Y + 1.4746 * V;
            g = Y - 0.164553 * U - 0.571353 * V;
            b = Y + 1.8814 * U;
        }
        else
        {
            // BT.709 full range
            r = Y + 1.5748 * V;
            g = Y - 0.187324 * U - 0.468124 * V;
            b = Y + 1.8556 * U;
        }
    }
    else
    {
        // Limited range - use coefficients with 1.164383 factor
        r = coeffs.r.x * Y + coeffs.r.y * U + coeffs.r.z * V;
        g = coeffs.g.x * Y + coeffs.g.y * U + coeffs.g.z * V;
        b = coeffs.b.x * Y + coeffs.b.y * U + coeffs.b.z * V;
    }
    
    // Clamp and store as BGR (OpenCV format)
    vec4 bgrColor = vec4(clamp(b, 0.0, 255.0) / 255.0, 
                         clamp(g, 0.0, 255.0) / 255.0, 
                         clamp(r, 0.0, 255.0) / 255.0, 
                         1.0);
    imageStore(bgrOutput, pixel, bgrColor);
}
