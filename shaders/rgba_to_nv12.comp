#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D srcImage;
layout(set = 0, binding = 1, r8) uniform writeonly image2D dstLuma;
layout(set = 0, binding = 2, rg8) uniform writeonly image2D dstChroma;

layout(push_constant) uniform Push {
    vec2 outputSize;
} pushC;

// BT.601 luma coefficients (matches video_blit usage)
const vec3 kLumaWeights = vec3(0.299, 0.587, 0.114);

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec2 uv = (vec2(pixel) + vec2(0.5)) / pushC.outputSize;
    vec3 rgb = texture(srcImage, uv).rgb;

    float luma = clamp(dot(rgb, kLumaWeights), 0.0, 1.0);
    imageStore(dstLuma, pixel, vec4(luma, 0.0, 0.0, 1.0));

    // 2x2 chroma sample at even coords
    if (((pixel.x & 1) == 0) && ((pixel.y & 1) == 0)) {
        vec2 baseUV = (vec2(pixel) + vec2(0.5)) / pushC.outputSize;
        vec2 dx = vec2(1.0 / pushC.outputSize.x, 0.0);
        vec2 dy = vec2(0.0, 1.0 / pushC.outputSize.y);

        vec3 c0 = texture(srcImage, baseUV).rgb;
        vec3 c1 = texture(srcImage, baseUV + dx).rgb;
        vec3 c2 = texture(srcImage, baseUV + dy).rgb;
        vec3 c3 = texture(srcImage, baseUV + dx + dy).rgb;
        vec3 avg = (c0 + c1 + c2 + c3) * 0.25;

        // BT.601 YUV conversion
        float y = dot(avg, kLumaWeights);
        float u = (avg.b - y) * 0.565 + 0.5;
        float v = (avg.r - y) * 0.713 + 0.5;
        imageStore(dstChroma, ivec2(pixel.x >> 1, pixel.y >> 1), vec4(u, v, 0.0, 1.0));
    }
}
