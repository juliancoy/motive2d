#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Output (same size as input)
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outImage;

// RGBA input
layout(set = 0, binding = 1) uniform sampler2D texRGBA;

// Curve LUT UBO (256 samples packed into 64 vec4s)
layout(set = 0, binding = 5) uniform CurveUBO {
    vec4 curve[64];
} curveUBO;

// Minimal push constants: only the output size for bounds
layout(push_constant) uniform Push {
    vec2 outputSize;            // pixels
    vec4 grading;               // exposure, contrast, saturation, pad
    vec4 shadows;               // rgb, w unused
    vec4 midtones;              // rgb, w unused
    vec4 highlights;            // rgb, w unused
} pushC;

// ---- Curve + grading ----
float sampleCurve(float value)
{
    value = clamp(value, 0.0, 1.0);
    float f = value * 255.0;
    int i = int(f);
    float frac = fract(f);

    if (i >= 255) {
        return curveUBO.curve[63][3];
    }

    int idx0 = i / 4;
    int comp0 = i % 4;
    int idx1 = (i + 1) / 4;
    int comp1 = (i + 1) % 4;

    float v0 = curveUBO.curve[idx0][comp0];
    float v1 = curveUBO.curve[idx1][comp1];
    return mix(v0, v1, frac);
}

vec3 applyGrading(vec3 color)
{
    // 1) Exposure (stops)
    color *= exp2(pushC.grading.x);

    // 2) 3-way correction
    float l = dot(color, vec3(0.299, 0.587, 0.114));
    float wS = 1.0 - smoothstep(0.0, 0.33, l);
    float wM = smoothstep(0.0, 0.33, l) - smoothstep(0.66, 1.0, l);
    float wH = smoothstep(0.66, 1.0, l);

    color = color * (wS * pushC.shadows.rgb +
                     wM * pushC.midtones.rgb +
                     wH * pushC.highlights.rgb);

    // 3) Contrast
    color = (color - 0.5) * pushC.grading.y + 0.5;

    // 4) Saturation
    float lum = dot(color, vec3(0.299, 0.587, 0.114));
    color = mix(vec3(lum), color, pushC.grading.z);

    // 5) Curve LUT
    color.r = sampleCurve(color.r);
    color.g = sampleCurve(color.g);
    color.b = sampleCurve(color.b);

    return color;
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    // 1:1 mapping input -> output
    vec2 uv = (vec2(pixel) + vec2(0.5)) / pushC.outputSize;

    vec4 src = texture(texRGBA, uv);
    vec3 rgb = applyGrading(src.rgb);

    imageStore(outImage, pixel, vec4(clamp(rgb, 0.0, 1.0), src.a));
}
