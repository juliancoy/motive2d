#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform image2D outImage;
layout(set = 0, binding = 1) uniform sampler2D glyph0;
layout(set = 0, binding = 2) uniform sampler2D glyph1;

layout(push_constant) uniform Push {
    ivec2 imageSize;
    vec4 backgroundColor;
    vec4 textColor;
    ivec2 lineOrigin[2];
    ivec2 lineSize[2];
    int lineCount;
} pushC;

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= pushC.imageSize.x || pixel.y >= pushC.imageSize.y)
    {
        return;
    }

    vec4 color = imageLoad(outImage, pixel);

    for (int i = 0; i < pushC.lineCount; ++i)
    {
        ivec2 origin = pushC.lineOrigin[i];
        ivec2 size = pushC.lineSize[i];
        if (size.x <= 0 || size.y <= 0)
        {
            continue;
        }
        if (pixel.x >= origin.x && pixel.x < origin.x + size.x &&
            pixel.y >= origin.y && pixel.y < origin.y + size.y)
        {
            if (pushC.backgroundColor.a > 0.0)
            {
                color = mix(color, pushC.backgroundColor, pushC.backgroundColor.a);
            }
            vec2 uv = (vec2(pixel) - vec2(origin)) / vec2(size);
            vec4 glyph = (i == 0) ? texture(glyph0, uv) : texture(glyph1, uv);
            float alpha = glyph.a;
            if (alpha > 0.0)
            {
                vec4 glyphColor = vec4(pushC.textColor.rgb, alpha);
                color = mix(color, glyphColor, alpha);
                color.a = max(color.a, alpha);
            }
        }
    }

    imageStore(outImage, pixel, color);
}
