#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_scalar_block_layout : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outImage;

struct Detection {
    vec4 bbox;
    vec4 color;
    float confidence;
    int class_id;
    int padding[2];
};

layout(set = 0, binding = 1, scalar) buffer DetectionBuffer {
    Detection detections[];
} detectionBuffer;

layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 rectCenter;
    vec2 rectSize;
    float outerThickness;
    float innerThickness;
    float detectionEnabled;
    uint detectionCount;
} pushC;

void drawKeypoint(vec2 frag, vec2 center, float radius, vec4 color, inout vec4 outColor) {
    float dist = distance(frag, center);
    if (dist <= radius) {
        outColor = color;
        if (dist >= radius - 2.0) {
            outColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
    }
}

void drawSkeletonLine(vec2 frag, vec2 p1, vec2 p2, vec4 color, inout vec4 outColor) {
    vec2 lineDir = p2 - p1;
    float lineLength = length(lineDir);
    if (lineLength < 0.001) {
        return;
    }
    vec2 lineDirNorm = lineDir / lineLength;
    vec2 toFrag = frag - p1;
    float t = clamp(dot(toFrag, lineDirNorm), 0.0, lineLength);
    vec2 closestPoint = p1 + lineDirNorm * t;
    float dist = distance(frag, closestPoint);
    if (dist <= 2.0) {
        outColor = color;
    }
}

void drawBoundingBox(vec2 frag, vec2 minP, vec2 maxP, vec4 color, inout vec4 outColor) {
    if (frag.x >= minP.x && frag.x <= maxP.x && frag.y >= minP.y && frag.y <= maxP.y) {
        float left = frag.x - minP.x;
        float right = maxP.x - frag.x;
        float top = maxP.y - frag.y;
        float bottom = frag.y - minP.y;
        float minEdge = min(min(left, right), min(top, bottom));
        const float border = 2.0;
        if (minEdge <= border) {
            outColor = color;
        }
    }
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);
    vec4 poseColor = vec4(0.0);
    if (pushC.detectionCount > 0) {
        vec2 keypoints[17];
        bool hasKeypoint[17];

        for (int i = 0; i < 17; i++) {
            hasKeypoint[i] = false;
        }

        for (uint i = 0; i < min(pushC.detectionCount, uint(detectionBuffer.detections.length())); i++) {
            Detection det = detectionBuffer.detections[i];
            if (det.class_id >= 100) {
                int keypoint_id = det.class_id - 100;
                if (keypoint_id >= 0 && keypoint_id < 17) {
                    vec2 boxCenter = det.bbox.xy + det.bbox.zw * 0.5;
                    vec2 boxSize = det.bbox.zw;
                    boxCenter *= pushC.outputSize;
                    boxSize *= pushC.outputSize;
                    keypoints[keypoint_id] = boxCenter;
                    hasKeypoint[keypoint_id] = true;
                    float radius = max(boxSize.x, boxSize.y) * 0.5;
                    drawKeypoint(frag, boxCenter, radius, det.color, poseColor);
                }
            }
            else {
                vec2 minP = det.bbox.xy * pushC.outputSize;
                vec2 maxP = (det.bbox.xy + det.bbox.zw) * pushC.outputSize;
                drawBoundingBox(frag, minP, maxP, det.color, poseColor);
            }
        }

        if (hasKeypoint[0] && hasKeypoint[1]) drawSkeletonLine(frag, keypoints[0], keypoints[1], vec4(1.0, 0.0, 0.0, 1.0), poseColor);
        if (hasKeypoint[0] && hasKeypoint[2]) drawSkeletonLine(frag, keypoints[0], keypoints[2], vec4(1.0, 0.0, 0.0, 1.0), poseColor);
        if (hasKeypoint[1] && hasKeypoint[3]) drawSkeletonLine(frag, keypoints[1], keypoints[3], vec4(1.0, 0.0, 0.0, 1.0), poseColor);
        if (hasKeypoint[2] && hasKeypoint[4]) drawSkeletonLine(frag, keypoints[2], keypoints[4], vec4(1.0, 0.0, 0.0, 1.0), poseColor);
        if (hasKeypoint[5] && hasKeypoint[6]) drawSkeletonLine(frag, keypoints[5], keypoints[6], vec4(0.0, 1.0, 0.0, 1.0), poseColor);
        if (hasKeypoint[5] && hasKeypoint[7]) drawSkeletonLine(frag, keypoints[5], keypoints[7], vec4(0.0, 1.0, 0.0, 1.0), poseColor);
        if (hasKeypoint[7] && hasKeypoint[9]) drawSkeletonLine(frag, keypoints[7], keypoints[9], vec4(0.0, 1.0, 0.0, 1.0), poseColor);
        if (hasKeypoint[6] && hasKeypoint[8]) drawSkeletonLine(frag, keypoints[6], keypoints[8], vec4(0.0, 1.0, 0.0, 1.0), poseColor);
        if (hasKeypoint[8] && hasKeypoint[10]) drawSkeletonLine(frag, keypoints[8], keypoints[10], vec4(0.0, 1.0, 0.0, 1.0), poseColor);
        if (hasKeypoint[5] && hasKeypoint[11]) drawSkeletonLine(frag, keypoints[5], keypoints[11], vec4(0.0, 0.0, 1.0, 1.0), poseColor);
        if (hasKeypoint[6] && hasKeypoint[12]) drawSkeletonLine(frag, keypoints[6], keypoints[12], vec4(0.0, 0.0, 1.0, 1.0), poseColor);
        if (hasKeypoint[11] && hasKeypoint[13]) drawSkeletonLine(frag, keypoints[11], keypoints[13], vec4(0.0, 0.0, 1.0, 1.0), poseColor);
        if (hasKeypoint[13] && hasKeypoint[15]) drawSkeletonLine(frag, keypoints[13], keypoints[15], vec4(0.0, 0.0, 1.0, 1.0), poseColor);
        if (hasKeypoint[12] && hasKeypoint[14]) drawSkeletonLine(frag, keypoints[12], keypoints[14], vec4(0.0, 0.0, 1.0, 1.0), poseColor);
        if (hasKeypoint[14] && hasKeypoint[16]) drawSkeletonLine(frag, keypoints[14], keypoints[16], vec4(0.0, 0.0, 1.0, 1.0), poseColor);
    }

    imageStore(outImage, pixel, poseColor);
}
