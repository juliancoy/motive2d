#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outImage;
layout(set = 0, binding = 3) uniform sampler2D texLuma;
layout(set = 0, binding = 4) uniform sampler2D texChroma;
layout(set = 0, binding = 5) uniform CurveUBO {
    vec4 curve[64]; // 256 samples packed
} curveUBO;

layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 videoSize;
    vec2 targetOrigin;
    vec2 targetSize;
    vec2 cropOrigin;
    vec2 cropSize;
    vec2 chromaDiv;
    uint colorSpace;
    uint colorRange;
    uint overlayEnabled;
    uint fpsOverlayEnabled;
    vec2 overlayOrigin;
    vec2 overlaySize;
    vec2 fpsOverlayOrigin;
    vec2 fpsOverlaySize;
    vec4 fpsOverlayBackground;
    float scrubProgress;
    float scrubPlaying;
    uint scrubberEnabled;
    uint padScrub0;
    uint padScrub1;
    uint padScrub2;
    vec4 grading;    // exposure, contrast, saturation, pad
    vec4 shadows;    // rgb, w unused
    vec4 midtones;   // rgb, w unused
    vec4 highlights; // rgb, w unused
} pushC;

const float kLimitedLumaOffset = 16.0 / 255.0;
const float kLimitedLumaRange = 219.0 / 255.0;
const float kLimitedChromaOffset = 128.0 / 255.0;
const float kLimitedChromaRange = 224.0 / 255.0;

float decodeLuma(float value, uint colorRange)
{
    if (colorRange == 1u)
    {
        return clamp(value, 0.0, 1.0);
    }
    return clamp((value - kLimitedLumaOffset) / kLimitedLumaRange, 0.0, 1.0);
}

float decodeChroma(float value, uint colorRange)
{
    if (colorRange == 1u)
    {
        return clamp(value - 0.5, -0.5, 0.5);
    }
    return clamp((value - kLimitedChromaOffset) / kLimitedChromaRange, -0.5, 0.5);
}

vec3 convertYuvToRgb(vec3 yuv, uint colorSpace)
{
    float y = yuv.x;
    float u = yuv.y;
    float v = yuv.z;
    if (colorSpace == 0u)
    {
        return vec3(
            y + 1.4019996 * v,
            y - 0.344136 * u - 0.714136 * v,
            y + 1.7720001 * u);
    }
    if (colorSpace == 1u)
    {
        return vec3(
            y + 1.5747999 * v,
            y - 0.18732418 * u - 0.46812421 * v,
            y + 1.8555999 * u);
    }
    return vec3(
        y + 1.4745998 * v,
        y - 0.16455278 * u - 0.57135301 * v,
        y + 1.8813999 * u);
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);

    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);

    // Sample video in its target region
    bool inVideo = frag.x >= pushC.targetOrigin.x &&
                   frag.y >= pushC.targetOrigin.y &&
                   frag.x <= (pushC.targetOrigin.x + pushC.targetSize.x) &&
                   frag.y <= (pushC.targetOrigin.y + pushC.targetSize.y);

    if (inVideo) {
        vec2 localUV = (frag - pushC.targetOrigin) / pushC.targetSize;
        vec2 videoUV = pushC.cropOrigin + localUV * pushC.cropSize;

        float ySample = texture(texLuma, videoUV).r;
        vec2 uvSample = texture(texChroma, videoUV).rg;
        float y = decodeLuma(ySample, pushC.colorRange);
        float u = decodeChroma(uvSample.r, pushC.colorRange);
        float v = decodeChroma(uvSample.g, pushC.colorRange);
        vec3 rgb = convertYuvToRgb(vec3(y, u, v), pushC.colorSpace);
        color = vec4(clamp(rgb, 0.0, 1.0), 1.0);
    }

    // Scrubber (optionally disabled)
    if (pushC.scrubberEnabled != 0u) {
        float margin = 20.0;
        float iconSize = 28.0;
        float minWidth = 200.0;
        float scrubHeight = 64.0;
        float scrubLeft = margin + iconSize + margin;
        float scrubWidth = max(pushC.outputSize.x - (scrubLeft + margin), minWidth);
        vec2 scrubSize = vec2(scrubWidth, scrubHeight);
        vec2 scrubOrigin = vec2(scrubLeft, pushC.outputSize.y - scrubSize.y - margin);
        bool inScrub = frag.x >= scrubOrigin.x &&
                       frag.y >= scrubOrigin.y &&
                       frag.x <= (scrubOrigin.x + scrubSize.x) &&
                       frag.y <= (scrubOrigin.y + scrubSize.y);
        if (inScrub) {
            vec2 uv = (frag - scrubOrigin) / scrubSize;
            // Background bar
            vec3 bg = vec3(0.08, 0.08, 0.08);
            vec3 fill = vec3(0.95, 0.45, 0.1);
            vec3 paused = vec3(0.2, 0.6, 1.0);
            vec3 fg = mix(paused, fill, pushC.scrubPlaying);
            float barH = 0.35;
            float yRel = abs(uv.y - 0.5);
            float band = step(yRel, barH * 0.5);
            float prog = clamp(pushC.scrubProgress, 0.0, 1.0);
            float xProg = uv.x <= prog ? 1.0 : 0.0;
            vec3 bar = mix(bg, fg, band * xProg);
            // Handle
            float handleX = prog;
            float handleRadius = 0.12;
            float dist = length(uv - vec2(handleX, 0.5));
            float handle = smoothstep(handleRadius, handleRadius * 0.7, handleRadius - dist);
            vec3 handleCol = vec3(1.0, 0.95, 0.4);
            // draw an outline ring to make the handle obvious
            float ring = smoothstep(handleRadius + 0.025, handleRadius, dist);
            vec3 ringColor = vec3(0.1, 0.1, 0.1);
            vec3 handleLayer = mix(bar, ringColor, ring);
            vec3 handleFill = mix(handleLayer, handleCol, handle);
            vec3 scrubColor = handleFill;
            color = vec4(scrubColor, 1.0);
        }

        // Play/pause icon to the left of the scrubber
        vec2 iconSizeV = vec2(iconSize, iconSize);
        vec2 iconOrigin = vec2(margin, scrubOrigin.y + (scrubSize.y - iconSizeV.y) * 0.5);
        bool inIcon = frag.x >= iconOrigin.x &&
                      frag.y >= iconOrigin.y &&
                      frag.x <= (iconOrigin.x + iconSizeV.x) &&
                      frag.y <= (iconOrigin.y + iconSizeV.y);
        if (inIcon) {
            vec2 uvIcon = (frag - iconOrigin) / iconSizeV;
            float alphaIcon = 0.0;
            if (pushC.scrubPlaying > 0.5) {
                // Pause: two vertical bars
                float barW = 0.22;
                float gap = 0.12;
                bool leftBar = uvIcon.x > gap && uvIcon.x < (gap + barW);
                bool rightBar = uvIcon.x > (1.0 - gap - barW) && uvIcon.x < (1.0 - gap);
                if ((leftBar || rightBar) && uvIcon.y > 0.1 && uvIcon.y < 0.9) {
                    alphaIcon = 1.0;
                }
            } else {
                // Play: left-pointing triangle (mirror the previous shape)
                if (uvIcon.x > 0.15 && uvIcon.x < 0.82) {
                    float t = (0.82 - uvIcon.x) / 0.67;
                    float yTop = mix(0.1, 0.9, t);
                    float yBot = mix(0.9, 0.1, t);
                    if (uvIcon.y > yBot && uvIcon.y < yTop) {
                        alphaIcon = 1.0;
                    }
                }
            }
            if (alphaIcon > 0.0) {
                vec3 iconColor = vec3(1.0);
                color = mix(color, vec4(iconColor, 1.0), alphaIcon);
            }
        }
    }

    imageStore(outImage, pixel, color);
}
