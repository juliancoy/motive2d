#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outImage;
layout(set = 0, binding = 1) uniform sampler2D texOverlay;      // rectangle overlay
layout(set = 0, binding = 2) uniform sampler2D texFpsOverlay;   // text overlay
layout(set = 0, binding = 3) uniform sampler2D texLuma;
layout(set = 0, binding = 4) uniform sampler2D texChroma;
layout(set = 0, binding = 5) uniform CurveUBO {
    vec4 curve[64]; // 256 samples packed
} curveUBO;

layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 videoSize;
    vec2 targetOrigin;
    vec2 targetSize;
    vec2 cropOrigin;
    vec2 cropSize;
    vec2 chromaDiv;
    uint colorSpace;
    uint colorRange;
    uint overlayEnabled;
    uint fpsOverlayEnabled;
    vec2 overlayOrigin;
    vec2 overlaySize;
    vec2 fpsOverlayOrigin;
    vec2 fpsOverlaySize;
    float scrubProgress;
    float scrubPlaying;
    uint scrubberEnabled;
    uint padScrub0;
    uint padScrub1;
    uint padScrub2;
    vec4 grading;    // exposure, contrast, saturation, pad
    vec4 shadows;    // rgb, w unused
    vec4 midtones;   // rgb, w unused
    vec4 highlights; // rgb, w unused
} pushC;

const float kLumaOffset = 16.0 / 255.0;
const float kLumaScaleLimited = 255.0 / 219.0;
const float kChromaScaleLimited = 255.0 / 224.0;

float convertLuma(float ySample, uint rangeFlag) {
    if (rangeFlag == 0u) {
        return clamp((ySample - kLumaOffset) * kLumaScaleLimited, 0.0, 1.0);
    }
    return ySample;
}

vec2 convertChroma(vec2 uvSample, uint rangeFlag) {
    if (rangeFlag == 0u) {
        return (uvSample - vec2(0.5)) * kChromaScaleLimited;
    }
    return uvSample - vec2(0.5);
}

vec3 yuvToRgb(float y, float u, float v, uint colorSpace) {
    vec3 rgb;
    if (colorSpace == 2u) {          // BT.2020
        rgb.r = y + 1.4746 * v;
        rgb.g = y - 0.164553 * u - 0.571353 * v;
        rgb.b = y + 1.8814 * u;
    } else if (colorSpace == 1u) {   // BT.709
        rgb.r = y + 1.5748 * v;
        rgb.g = y - 0.187324 * u - 0.468124 * v;
        rgb.b = y + 1.8556 * u;
    } else {                         // BT.601
        rgb.r = y + 1.402 * v;
        rgb.g = y - 0.344136 * u - 0.714136 * v;
        rgb.b = y + 1.772 * u;
    }
    return clamp(rgb, 0.0, 1.0);
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);

    // Default to background
    // Start with a solid green so overlay visibility is obvious
    vec4 color = vec4(0.0, 1.0, 0.0, 1.0);

    // Sample video in its target region
    bool inVideo = frag.x >= pushC.targetOrigin.x &&
                   frag.y >= pushC.targetOrigin.y &&
                   frag.x <= (pushC.targetOrigin.x + pushC.targetSize.x) &&
                   frag.y <= (pushC.targetOrigin.y + pushC.targetSize.y);

    if (inVideo) {
        vec2 localUV = (frag - pushC.targetOrigin) / pushC.targetSize;
        vec2 videoUV = pushC.cropOrigin + localUV * pushC.cropSize;

        float ySample = texture(texLuma, videoUV).r;
    vec2 uvSample = texture(texChroma, videoUV).rg;
        vec2 uv = convertChroma(uvSample, pushC.colorRange);
        float y = convertLuma(ySample, pushC.colorRange);
        vec3 rgb = yuvToRgb(y, uv.x, uv.y, pushC.colorSpace);
        // Curve LUT applied per channel (piecewise linear over 256 samples)
        float lutCoordR = clamp(rgb.r, 0.0, 1.0) * 255.0;
        float lutCoordG = clamp(rgb.g, 0.0, 1.0) * 255.0;
        float lutCoordB = clamp(rgb.b, 0.0, 1.0) * 255.0;
        int lutIdxR = int(floor(lutCoordR));
        int lutIdxG = int(floor(lutCoordG));
        int lutIdxB = int(floor(lutCoordB));
        float lutFractR = fract(lutCoordR);
        float lutFractG = fract(lutCoordG);
        float lutFractB = fract(lutCoordB);
        int blockR = lutIdxR >> 2;
        int laneR = lutIdxR & 3;
        int blockR1 = min((lutIdxR + 1) >> 2, 63);
        int laneR1 = (lutIdxR + 1) & 3;
        int blockG = lutIdxG >> 2;
        int laneG = lutIdxG & 3;
        int blockG1 = min((lutIdxG + 1) >> 2, 63);
        int laneG1 = (lutIdxG + 1) & 3;
        int blockB = lutIdxB >> 2;
        int laneB = lutIdxB & 3;
        int blockB1 = min((lutIdxB + 1) >> 2, 63);
        int laneB1 = (lutIdxB + 1) & 3;
        float lutR = mix(curveUBO.curve[blockR][laneR], curveUBO.curve[blockR1][laneR1], lutFractR);
        float lutG = mix(curveUBO.curve[blockG][laneG], curveUBO.curve[blockG1][laneG1], lutFractG);
        float lutB = mix(curveUBO.curve[blockB][laneB], curveUBO.curve[blockB1][laneB1], lutFractB);
        rgb = vec3(lutR, lutG, lutB);
        // Apply grading: contrast then exposure, then saturation
        rgb = rgb * pushC.grading.y + vec3(pushC.grading.x);
        float luma = dot(rgb, vec3(0.299, 0.587, 0.114));
        rgb = mix(vec3(luma), rgb, pushC.grading.z);
        // Shadows / midtones / highlights weighting
        float shadowW = clamp(1.0 - luma * 2.0, 0.0, 1.0);
        float highlightW = clamp((luma - 0.5) * 2.0, 0.0, 1.0);
        float midW = clamp(1.0 - abs(luma - 0.5) * 2.0, 0.0, 1.0);
        rgb *= mix(vec3(1.0), vec3(pushC.shadows), shadowW);
        rgb *= mix(vec3(1.0), vec3(pushC.midtones), midW);
        rgb *= mix(vec3(1.0), vec3(pushC.highlights), highlightW);
        rgb = clamp(rgb, 0.0, 1.0);
        color = vec4(rgb, 1.0);
    }

    // Scrubber (optionally disabled)
    if (pushC.scrubberEnabled != 0u) {
        float margin = 20.0;
        float iconSize = 28.0;
        float minWidth = 200.0;
        float scrubHeight = 64.0;
        float scrubLeft = margin + iconSize + margin;
        float scrubWidth = max(pushC.outputSize.x - (scrubLeft + margin), minWidth);
        vec2 scrubSize = vec2(scrubWidth, scrubHeight);
        vec2 scrubOrigin = vec2(scrubLeft, pushC.outputSize.y - scrubSize.y - margin);
        bool inScrub = frag.x >= scrubOrigin.x &&
                       frag.y >= scrubOrigin.y &&
                       frag.x <= (scrubOrigin.x + scrubSize.x) &&
                       frag.y <= (scrubOrigin.y + scrubSize.y);
        if (inScrub) {
            vec2 uv = (frag - scrubOrigin) / scrubSize;
            // Background bar
            vec3 bg = vec3(0.08, 0.08, 0.08);
            vec3 fill = vec3(0.95, 0.45, 0.1);
            vec3 paused = vec3(0.2, 0.6, 1.0);
            vec3 fg = mix(paused, fill, pushC.scrubPlaying);
            float barH = 0.35;
            float yRel = abs(uv.y - 0.5);
            float band = step(yRel, barH * 0.5);
            float prog = clamp(pushC.scrubProgress, 0.0, 1.0);
            float xProg = uv.x <= prog ? 1.0 : 0.0;
            vec3 bar = mix(bg, fg, band * xProg);
            // Handle
            float handleX = prog;
            float handleRadius = 0.12;
            float dist = length(uv - vec2(handleX, 0.5));
            float handle = smoothstep(handleRadius, handleRadius * 0.7, handleRadius - dist);
            vec3 handleCol = vec3(1.0, 0.95, 0.4);
            // draw an outline ring to make the handle obvious
            float ring = smoothstep(handleRadius + 0.025, handleRadius, dist);
            vec3 ringColor = vec3(0.1, 0.1, 0.1);
            vec3 handleLayer = mix(bar, ringColor, ring);
            vec3 handleFill = mix(handleLayer, handleCol, handle);
            vec3 scrubColor = handleFill;
            color = vec4(scrubColor, 1.0);
        }

        // Play/pause icon to the left of the scrubber
        vec2 iconSizeV = vec2(iconSize, iconSize);
        vec2 iconOrigin = vec2(margin, scrubOrigin.y + (scrubSize.y - iconSizeV.y) * 0.5);
        bool inIcon = frag.x >= iconOrigin.x &&
                      frag.y >= iconOrigin.y &&
                      frag.x <= (iconOrigin.x + iconSizeV.x) &&
                      frag.y <= (iconOrigin.y + iconSizeV.y);
        if (inIcon) {
            vec2 uvIcon = (frag - iconOrigin) / iconSizeV;
            float alphaIcon = 0.0;
            if (pushC.scrubPlaying > 0.5) {
                // Pause: two vertical bars
                float barW = 0.22;
                float gap = 0.12;
                bool leftBar = uvIcon.x > gap && uvIcon.x < (gap + barW);
                bool rightBar = uvIcon.x > (1.0 - gap - barW) && uvIcon.x < (1.0 - gap);
                if ((leftBar || rightBar) && uvIcon.y > 0.1 && uvIcon.y < 0.9) {
                    alphaIcon = 1.0;
                }
            } else {
                // Play: left-pointing triangle (mirror the previous shape)
                if (uvIcon.x > 0.15 && uvIcon.x < 0.82) {
                    float t = (0.82 - uvIcon.x) / 0.67;
                    float yTop = mix(0.1, 0.9, t);
                    float yBot = mix(0.9, 0.1, t);
                    if (uvIcon.y > yBot && uvIcon.y < yTop) {
                        alphaIcon = 1.0;
                    }
                }
            }
            if (alphaIcon > 0.0) {
                vec3 iconColor = vec3(1.0);
                color = mix(color, vec4(iconColor, 1.0), alphaIcon);
            }
        }
    }

    // Overlay on top; if enabled and inside overlay region, alpha blend overlay texel
    if (pushC.overlayEnabled != 0u) {
        bool inOverlay = frag.x >= pushC.overlayOrigin.x &&
                         frag.y >= pushC.overlayOrigin.y &&
                         frag.x <= (pushC.overlayOrigin.x + pushC.overlaySize.x) &&
                         frag.y <= (pushC.overlayOrigin.y + pushC.overlaySize.y);
        if (inOverlay) {
            vec2 overlayUV = (frag - pushC.overlayOrigin) / pushC.overlaySize;
            vec4 overlaySample = texture(texOverlay, overlayUV);
            color = mix(color, overlaySample, overlaySample.a);
        }
    }

    // FPS overlay (font-rendered) on top of everything else
    if (pushC.fpsOverlayEnabled != 0u) {
        bool inFps = frag.x >= pushC.fpsOverlayOrigin.x &&
                     frag.y >= pushC.fpsOverlayOrigin.y &&
                     frag.x <= (pushC.fpsOverlayOrigin.x + pushC.fpsOverlaySize.x) &&
                     frag.y <= (pushC.fpsOverlayOrigin.y + pushC.fpsOverlaySize.y);
        if (inFps) {
            vec2 fpsUV = (frag - pushC.fpsOverlayOrigin) / pushC.fpsOverlaySize;
            vec4 fpsSample = texture(texFpsOverlay, fpsUV);
            color = mix(color, fpsSample, fpsSample.a);
        }
    }

    imageStore(outImage, pixel, color);
}
