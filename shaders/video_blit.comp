#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outImage;
layout(set = 0, binding = 3) uniform sampler2D texLuma;
layout(set = 0, binding = 4) uniform sampler2D texChroma;
layout(set = 0, binding = 5) uniform CurveUBO {
    vec4 curve[64]; // 256 samples packed
} curveUBO;

layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 videoSize;
    vec2 targetOrigin;
    vec2 targetSize;
    vec2 cropOrigin;
    vec2 cropSize;
    vec2 chromaDiv;
    uint colorSpace;
    uint colorRange;
    uint overlayEnabled;
    uint fpsOverlayEnabled;
    vec2 overlayOrigin;
    vec2 overlaySize;
    vec2 fpsOverlayOrigin;
    vec2 fpsOverlaySize;
    vec4 fpsOverlayBackground;
    float scrubProgress;
    float scrubPlaying;
    uint scrubberEnabled;
    uint padScrub0;
    uint padScrub1;
    uint padScrub2;
    vec4 grading;    // exposure, contrast, saturation, pad
    vec4 shadows;    // rgb, w unused
    vec4 midtones;   // rgb, w unused
    vec4 highlights; // rgb, w unused
} pushC;

const float kLimitedLumaOffset = 16.0 / 255.0;
const float kLimitedLumaRange = 219.0 / 255.0;
const float kLimitedChromaOffset = 128.0 / 255.0;
const float kLimitedChromaRange = 224.0 / 255.0;

float decodeLuma(float value, uint colorRange)
{
    if (colorRange == 1u)
    {
        return clamp(value, 0.0, 1.0);
    }
    return clamp((value - kLimitedLumaOffset) / kLimitedLumaRange, 0.0, 1.0);
}

float decodeChroma(float value, uint colorRange)
{
    if (colorRange == 1u)
    {
        return clamp(value - 0.5, -0.5, 0.5);
    }
    return clamp((value - kLimitedChromaOffset) / kLimitedChromaRange, -0.5, 0.5);
}

vec3 convertYuvToRgb(vec3 yuv, uint colorSpace)
{
    float y = yuv.x;
    float u = yuv.y;
    float v = yuv.z;
    if (colorSpace == 0u)
    {
        return vec3(
            y + 1.4019996 * v,
            y - 0.344136 * u - 0.714136 * v,
            y + 1.7720001 * u);
    }
    if (colorSpace == 1u)
    {
        return vec3(
            y + 1.5747999 * v,
            y - 0.18732418 * u - 0.46812421 * v,
            y + 1.8555999 * u);
    }
    return vec3(
        y + 1.4745998 * v,
        y - 0.16455278 * u - 0.57135301 * v,
        y + 1.8813999 * u);
}

// Color grading functions
float sampleCurve(float value) {
    value = clamp(value, 0.0, 1.0);
    float f = value * 255.0;
    int i = int(f);
    float frac = fract(f);
    int idx0 = i / 4;
    int comp0 = i % 4;
    int idx1 = (i + 1) / 4;
    int comp1 = (i + 1) % 4;

    if (i >= 255) {
        return curveUBO.curve[63][3];
    }

    float v0 = curveUBO.curve[idx0][comp0];
    float v1 = curveUBO.curve[idx1][comp1];
    return mix(v0, v1, frac);
}

vec3 applyGrading(vec3 color) {
    // 1. Exposure
    color *= pow(2.0, pushC.grading.x);

    // 2. 3-way color correction
    float l = dot(color, vec3(0.299, 0.587, 0.114));
    float shadows_weight = 1.0 - smoothstep(0.0, 0.33, l);
    float midtones_weight = smoothstep(0.0, 0.33, l) - smoothstep(0.66, 1.0, l);
    float highlights_weight = smoothstep(0.66, 1.0, l);

    vec3 graded_color = color * (shadows_weight * pushC.shadows.rgb + midtones_weight * pushC.midtones.rgb + highlights_weight * pushC.highlights.rgb);
    color = graded_color;

    // 3. Contrast
    color = (color - 0.5) * pushC.grading.y + 0.5;
    
    // 4. Saturation
    float luminance = dot(color, vec3(0.299, 0.587, 0.114));
    color = mix(vec3(luminance), color, pushC.grading.z);

    // 5. Curve LUT
    color.r = sampleCurve(color.r);
    color.g = sampleCurve(color.g);
    color.b = sampleCurve(color.b);

    return color;
}


void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);

    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);

    // Sample video in its target region
    bool inVideo = frag.x >= pushC.targetOrigin.x &&
                   frag.y >= pushC.targetOrigin.y &&
                   frag.x <= (pushC.targetOrigin.x + pushC.targetSize.x) &&
                   frag.y <= (pushC.targetOrigin.y + pushC.targetSize.y);

    if (inVideo) {
        vec2 localUV = (frag - pushC.targetOrigin) / pushC.targetSize;
        vec2 videoUV = pushC.cropOrigin + localUV * pushC.cropSize;

        float ySample = texture(texLuma, videoUV).r;
        vec2 uvSample = texture(texChroma, videoUV).rg;
        float y = decodeLuma(ySample, pushC.colorRange);
        float u = decodeChroma(uvSample.r, pushC.colorRange);
        float v = decodeChroma(uvSample.g, pushC.colorRange);
        vec3 rgb = convertYuvToRgb(vec3(y, u, v), pushC.colorSpace);
        
        // Apply color grading
        rgb = applyGrading(rgb);

        color = vec4(clamp(rgb, 0.0, 1.0), 1.0);
    }

    imageStore(outImage, pixel, color);
}
