#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outImage;
layout(set = 0, binding = 3) uniform sampler2D texLuma;
layout(set = 0, binding = 4) uniform sampler2D texChroma;

layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 videoSize;
    vec2 targetOrigin;
    vec2 targetSize;
    vec2 cropOrigin;
    vec2 cropSize;
    vec2 chromaDiv;
    uint colorSpace;
    uint colorRange;
    uint overlayEnabled;
    uint fpsOverlayEnabled;
    vec2 overlayOrigin;
    vec2 overlaySize;
    vec2 fpsOverlayOrigin;
    vec2 fpsOverlaySize;
    vec4 fpsOverlayBackground;
    float scrubProgress;
    float scrubPlaying;
    uint scrubberEnabled;
    uint padScrub0;
    uint padScrub1;
    uint padScrub2;
    vec4 grading;
    vec4 shadows;
    vec4 midtones;
    vec4 highlights;
} pushC;

const float kLimitedLumaOffset = 16.0 / 255.0;
const float kLimitedLumaRange = 219.0 / 255.0;
const float kLimitedChromaOffset = 128.0 / 255.0;
const float kLimitedChromaRange = 224.0 / 255.0;

float decodeLuma(float value, uint colorRange)
{
    if (colorRange == 1u)
    {
        return clamp(value, 0.0, 1.0);
    }
    return clamp((value - kLimitedLumaOffset) / kLimitedLumaRange, 0.0, 1.0);
}

float decodeChroma(float value, uint colorRange)
{
    if (colorRange == 1u)
    {
        return clamp(value - 0.5, -0.5, 0.5);
    }
    return clamp((value - kLimitedChromaOffset) / kLimitedChromaRange, -0.5, 0.5);
}

vec3 convertYuvToRgb(vec3 yuv, uint colorSpace)
{
    float y = yuv.x;
    float u = yuv.y;
    float v = yuv.z;
    if (colorSpace == 0u)
    {
        return vec3(
            y + 1.4019996 * v,
            y - 0.344136 * u - 0.714136 * v,
            y + 1.7720001 * u);
    }
    if (colorSpace == 1u)
    {
        return vec3(
            y + 1.5747999 * v,
            y - 0.18732418 * u - 0.46812421 * v,
            y + 1.8555999 * u);
    }
    return vec3(
        y + 1.4745998 * v,
        y - 0.16455278 * u - 0.57135301 * v,
        y + 1.8813999 * u);
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y))
    {
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);
    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);

    bool inVideo = frag.x >= pushC.targetOrigin.x &&
                   frag.y >= pushC.targetOrigin.y &&
                   frag.x <= (pushC.targetOrigin.x + pushC.targetSize.x) &&
                   frag.y <= (pushC.targetOrigin.y + pushC.targetSize.y);

    if (inVideo)
    {
        vec2 localUV = (frag - pushC.targetOrigin) / pushC.targetSize;
        vec2 videoUV = pushC.cropOrigin + localUV * pushC.cropSize;

        float ySample = texture(texLuma, videoUV).r;
        vec2 uvSample = texture(texChroma, videoUV).rg;
        float y = decodeLuma(ySample, pushC.colorRange);
        float u = decodeChroma(uvSample.r, pushC.colorRange);
        float v = decodeChroma(uvSample.g, pushC.colorRange);
        vec3 rgb = convertYuvToRgb(vec3(y, u, v), pushC.colorSpace);
        color = vec4(clamp(rgb, 0.0, 1.0), 1.0);
    }

    imageStore(outImage, pixel, color);
}
