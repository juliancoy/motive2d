#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform readonly image2D poseImage;
layout(set = 0, binding = 1, rgba8) uniform writeonly image2D overlayImage;

layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 rectCenter;
    vec2 rectSize;
    float outerThickness;
    float innerThickness;
    float detectionEnabled; // 0.0 = false, 1.0 = true
    float overlayActive;
} pushC;

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec4 existing = imageLoad(poseImage, pixel);
    vec4 finalColor = existing;

    if (pushC.overlayActive <= 0.5) {
        finalColor = vec4(0.0);
        imageStore(overlayImage, pixel, finalColor);
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);
    vec2 halfSize = pushC.rectSize * 0.5;
    vec2 minP = pushC.rectCenter - halfSize;
    vec2 maxP = pushC.rectCenter + halfSize;

    if (pushC.detectionEnabled > 0.5) {
        if (frag.x >= minP.x && frag.x <= maxP.x && frag.y >= minP.y && frag.y <= maxP.y) {
            float distLeft = frag.x - minP.x;
            float distRight = maxP.x - frag.x;
            float distTop = maxP.y - frag.y;
            float distBottom = frag.y - minP.y;
            float minEdge = min(min(distLeft, distRight), min(distTop, distBottom));

            vec4 color = vec4(0.0);
            if (minEdge <= pushC.outerThickness) {
                color = vec4(1.0, 0.0, 0.0, 1.0);
            } else if (minEdge <= (pushC.outerThickness + pushC.innerThickness)) {
                color = vec4(1.0, 0.5, 0.5, 1.0);
            }

            if (color.a > 0.0) {
                finalColor = color;
            }
        }
    }

    imageStore(overlayImage, pixel, finalColor);
}
