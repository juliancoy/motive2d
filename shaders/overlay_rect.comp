#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outImage;

layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 rectCenter;
    vec2 rectSize;
    float outerThickness;
    float innerThickness;
    float detectionEnabled; // 0.0 = false, 1.0 = true
    vec2 detectionBoxCenter;
    vec2 detectionBoxSize;
} pushC;

void drawDetectionBox(vec2 frag, vec2 boxCenter, vec2 boxSize, inout vec4 color) {
    vec2 halfSize = boxSize * 0.5;
    vec2 minP = boxCenter - halfSize;
    vec2 maxP = boxCenter + halfSize;
    
    if (frag.x >= minP.x && frag.x <= maxP.x && 
        frag.y >= minP.y && frag.y <= maxP.y) {
        float distLeft = frag.x - minP.x;
        float distRight = maxP.x - frag.x;
        float distTop = maxP.y - frag.y;
        float distBottom = frag.y - minP.y;
        float minEdge = min(min(distLeft, distRight), min(distTop, distBottom));
        
        if (minEdge <= 2.0) { // 2 pixel border for detection box
            color = vec4(0.0, 1.0, 0.0, 1.0); // Green border for detection box
        } else if (minEdge <= 4.0) {
            // Light green fill for detection box interior
            color = mix(color, vec4(0.0, 0.5, 0.0, 0.3), 0.5);
        }
    }
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);
    vec2 halfSize = pushC.rectSize * 0.5;
    vec2 minP = pushC.rectCenter - halfSize;
    vec2 maxP = pushC.rectCenter + halfSize;

    // Outside rect: fully transparent
    if (frag.x < minP.x || frag.x > maxP.x || frag.y < minP.y || frag.y > maxP.y) {
        imageStore(outImage, pixel, vec4(0.0));
        return;
    }

    float distLeft = frag.x - minP.x;
    float distRight = maxP.x - frag.x;
    float distTop = maxP.y - frag.y;
    float distBottom = frag.y - minP.y;
    float minEdge = min(min(distLeft, distRight), min(distTop, distBottom));

    vec4 color = vec4(0.0);
    if (minEdge <= pushC.outerThickness) {
        if (pushC.detectionEnabled > 0.5) {
            color = vec4(1.0, 0.0, 0.0, 1.0); // Red for detection mode
        } else {
            color = vec4(0.0, 0.0, 0.0, 1.0); // Black otherwise
        }
    } else if (minEdge <= (pushC.outerThickness + pushC.innerThickness)) {
        if (pushC.detectionEnabled > 0.5) {
            color = vec4(1.0, 0.5, 0.5, 1.0); // Light red for inner border
        } else {
            color = vec4(1.0, 1.0, 1.0, 1.0); // White otherwise
        }
    }

    // Draw detection boxes if enabled
    if (pushC.detectionEnabled > 0.5) {
        // Main detection box (passed from CPU)
        // TODO: Replace with actual YOLO detection results
        // For real YOLO integration, use a storage buffer containing multiple detection boxes
        // with positions, sizes, confidence scores, and class labels
        drawDetectionBox(frag, pushC.detectionBoxCenter, pushC.detectionBoxSize, color);
        
        // Additional simulated detection boxes (demonstration only)
        // In a real implementation, these would come from YOLO inference results
        vec2 box2Center = pushC.detectionBoxCenter + vec2(pushC.detectionBoxSize.x * 0.3, -pushC.detectionBoxSize.y * 0.2);
        vec2 box2Size = pushC.detectionBoxSize * 0.7;
        drawDetectionBox(frag, box2Center, box2Size, color);
        
        vec2 box3Center = pushC.detectionBoxCenter + vec2(-pushC.detectionBoxSize.x * 0.4, pushC.detectionBoxSize.y * 0.3);
        vec2 box3Size = pushC.detectionBoxSize * 0.6;
        drawDetectionBox(frag, box3Center, box3Size, color);
        
        vec2 box4Center = pushC.detectionBoxCenter + vec2(pushC.detectionBoxSize.x * 0.2, pushC.detectionBoxSize.y * 0.4);
        vec2 box4Size = pushC.detectionBoxSize * 0.5;
        drawDetectionBox(frag, box4Center, box4Size, color);
    }

    imageStore(outImage, pixel, color);
}
