#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_scalar_block_layout : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outImage;

// Detection buffer structure (matches C++ GPUDetection struct)
struct Detection {
    vec4 bbox;        // x, y, width, height (normalized 0-1)
    vec4 color;       // rgba color for visualization
    float confidence; // confidence score
    int class_id;     // class identifier
    int padding[2];   // padding for alignment
};

// Storage buffer for detections
layout(set = 0, binding = 1, scalar) buffer DetectionBuffer {
    Detection detections[];
} detectionBuffer;

// Push constants for basic overlay parameters
layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 rectCenter;
    vec2 rectSize;
    float outerThickness;
    float innerThickness;
    float detectionEnabled; // 0.0 = false, 1.0 = true
    uint detectionCount;    // Number of active detections
} pushC;

// Draw a single detection box
void drawDetectionBox(vec2 frag, vec2 boxCenter, vec2 boxSize, vec4 boxColor, int class_id, inout vec4 color) {
    vec2 halfSize = boxSize * 0.5;
    vec2 minP = boxCenter - halfSize;
    vec2 maxP = boxCenter + halfSize;
    
    // Check if fragment is inside the box
    if (frag.x >= minP.x && frag.x <= maxP.x && 
        frag.y >= minP.y && frag.y <= maxP.y) {
        
        float distLeft = frag.x - minP.x;
        float distRight = maxP.x - frag.x;
        float distTop = maxP.y - frag.y;
        float distBottom = frag.y - minP.y;
        float minEdge = min(min(distLeft, distRight), min(distTop, distBottom));
        
        // For keypoints (class_id >= 100), draw as circles
        if (class_id >= 100) {
            // Calculate distance from center
            vec2 center = boxCenter;
            float radius = max(boxSize.x, boxSize.y) * 0.5;
            float dist = distance(frag, center);
            
            if (dist <= radius) {
                // Draw solid circle for keypoints
                color = boxColor;
                // Add a white border
                if (dist >= radius - 2.0) {
                    color = vec4(1.0, 1.0, 1.0, 1.0);
                }
            }
        } else {
            // Regular bounding box
            // Draw border (2 pixels)
            if (minEdge <= 2.0) {
                color = boxColor; // Use the detection color for border
            } 
            // Draw semi-transparent interior
            else if (minEdge <= 4.0) {
                vec4 fillColor = vec4(boxColor.rgb * 0.7, boxColor.a * 0.3);
                color = mix(color, fillColor, 0.5);
            }
        }
    }
}

// Draw confidence text (simplified - would need font texture in real implementation)
void drawConfidence(vec2 frag, vec2 boxCenter, vec2 boxSize, float confidence, inout vec4 color) {
    // Simplified confidence visualization - draw a small bar at top of box
    vec2 halfSize = boxSize * 0.5;
    vec2 minP = boxCenter - halfSize;
    vec2 maxP = boxCenter + halfSize;
    
    // Confidence bar at top of detection box
    float barHeight = 4.0;
    vec2 barMin = vec2(minP.x, maxP.y - barHeight);
    vec2 barMax = vec2(minP.x + boxSize.x * confidence, maxP.y);
    
    if (frag.x >= barMin.x && frag.x <= barMax.x && 
        frag.y >= barMin.y && frag.y <= barMax.y) {
        // Color based on confidence (red to green)
        vec4 barColor = mix(vec4(1.0, 0.0, 0.0, 1.0), vec4(0.0, 1.0, 0.0, 1.0), confidence);
        color = barColor;
    }
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);
    vec2 normalizedFrag = frag / pushC.outputSize;
    
    vec2 halfSize = pushC.rectSize * 0.5;
    vec2 minP = pushC.rectCenter - halfSize;
    vec2 maxP = pushC.rectCenter + halfSize;

    // Outside rect: fully transparent
    if (frag.x < minP.x || frag.x > maxP.x || frag.y < minP.y || frag.y > maxP.y) {
        imageStore(outImage, pixel, vec4(0.0));
        return;
    }

    float distLeft = frag.x - minP.x;
    float distRight = maxP.x - frag.x;
    float distTop = maxP.y - frag.y;
    float distBottom = frag.y - minP.y;
    float minEdge = min(min(distLeft, distRight), min(distTop, distBottom));

    vec4 color = vec4(0.0);
    if (minEdge <= pushC.outerThickness) {
        if (pushC.detectionEnabled > 0.5) {
            color = vec4(1.0, 0.0, 0.0, 1.0); // Red for detection mode
        } else {
            color = vec4(0.0, 0.0, 0.0, 1.0); // Black otherwise
        }
    } else if (minEdge <= (pushC.outerThickness + pushC.innerThickness)) {
        if (pushC.detectionEnabled > 0.5) {
            color = vec4(1.0, 0.5, 0.5, 1.0); // Light red for inner border
        } else {
            color = vec4(1.0, 1.0, 1.0, 1.0); // White otherwise
        }
    }

    // Draw YOLO detection boxes if enabled
    if (pushC.detectionEnabled > 0.5 && pushC.detectionCount > 0) {
        // Iterate through all active detections
        for (uint i = 0; i < min(pushC.detectionCount, uint(detectionBuffer.detections.length())); i++) {
            Detection det = detectionBuffer.detections[i];
            
            // Convert normalized bbox to screen coordinates
            vec2 boxCenter = det.bbox.xy + det.bbox.zw * 0.5;
            vec2 boxSize = det.bbox.zw;
            
            // Scale to output size
            boxCenter *= pushC.outputSize;
            boxSize *= pushC.outputSize;
            
            // Draw the detection box
            drawDetectionBox(frag, boxCenter, boxSize, det.color, det.class_id, color);
            
            // Draw confidence bar
            drawConfidence(frag, boxCenter, boxSize, det.confidence, color);
        }
    }

    imageStore(outImage, pixel, color);
}
