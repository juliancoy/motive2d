#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform image2D outImage;

layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 videoSize;
    vec2 targetOrigin;
    vec2 targetSize;
    vec2 cropOrigin;
    vec2 cropSize;
    vec2 chromaDiv;
    uint colorSpace;
    uint colorRange;
    uint overlayEnabled;
    uint fpsOverlayEnabled;
    vec2 overlayOrigin;
    vec2 overlaySize;
    vec2 fpsOverlayOrigin;
    vec2 fpsOverlaySize;
    vec4 fpsOverlayBackground;
    float scrubProgress;
    float scrubPlaying;
    uint scrubberEnabled;
    uint padScrub0;
    uint padScrub1;
    uint padScrub2;
    vec4 grading;
    vec4 shadows;
    vec4 midtones;
    vec4 highlights;
} pushC;

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);
    vec4 color = imageLoad(outImage, pixel);

    if (pushC.scrubberEnabled == 0u) {
        imageStore(outImage, pixel, color);
        return;
    }

    float margin = 20.0;
    float iconSize = 28.0;
    float minWidth = 200.0;
    float scrubHeight = 64.0;
    float scrubLeft = margin + iconSize + margin;
    float scrubWidth = max(pushC.outputSize.x - (scrubLeft + margin), minWidth);
    vec2 scrubSize = vec2(scrubWidth, scrubHeight);
    vec2 scrubOrigin = vec2(scrubLeft, pushC.outputSize.y - scrubSize.y - margin);
    bool inScrub = frag.x >= scrubOrigin.x &&
                   frag.y >= scrubOrigin.y &&
                   frag.x <= (scrubOrigin.x + scrubSize.x) &&
                   frag.y <= (scrubOrigin.y + scrubSize.y);
    if (inScrub) {
        vec2 uv = (frag - scrubOrigin) / scrubSize;
        vec3 bg = vec3(0.08, 0.08, 0.08);
        vec3 fill = vec3(0.95, 0.45, 0.1);
        vec3 paused = vec3(0.2, 0.6, 1.0);
        vec3 fg = mix(paused, fill, pushC.scrubPlaying);
        float barH = 0.35;
        float yRel = abs(uv.y - 0.5);
        float band = step(yRel, barH * 0.5);
        float prog = clamp(pushC.scrubProgress, 0.0, 1.0);
        float xProg = uv.x <= prog ? 1.0 : 0.0;
        vec3 bar = mix(bg, fg, band * xProg);
        float handleX = prog;
        float handleRadius = 0.12;
        float dist = length(uv - vec2(handleX, 0.5));
        float handle = smoothstep(handleRadius, handleRadius * 0.7, handleRadius - dist);
        vec3 handleCol = vec3(1.0, 0.95, 0.4);
        float ring = smoothstep(handleRadius + 0.025, handleRadius, dist);
        vec3 ringColor = vec3(0.1, 0.1, 0.1);
        vec3 handleLayer = mix(bar, ringColor, ring);
        vec3 handleFill = mix(handleLayer, handleCol, handle);
        vec3 scrubColor = handleFill;
        color = vec4(scrubColor, 1.0);
    }

    vec2 iconSizeV = vec2(iconSize, iconSize);
    vec2 iconOrigin = vec2(margin, scrubOrigin.y + (scrubSize.y - iconSizeV.y) * 0.5);
    bool inIcon = frag.x >= iconOrigin.x &&
                  frag.y >= iconOrigin.y &&
                  frag.x <= (iconOrigin.x + iconSizeV.x) &&
                  frag.y <= (iconOrigin.y + iconSizeV.y);
    if (inIcon) {
        vec2 uvIcon = (frag - iconOrigin) / iconSizeV;
        float alphaIcon = 0.0;
        if (pushC.scrubPlaying > 0.5) {
            float barW = 0.22;
            float gap = 0.12;
            bool leftBar = uvIcon.x > gap && uvIcon.x < (gap + barW);
            bool rightBar = uvIcon.x > (1.0 - gap - barW) && uvIcon.x < (1.0 - gap);
            if ((leftBar || rightBar) && uvIcon.y > 0.1 && uvIcon.y < 0.9) {
                alphaIcon = 1.0;
            }
        } else {
            if (uvIcon.x > 0.15 && uvIcon.x < 0.82) {
                float t = (0.82 - uvIcon.x) / 0.67;
                float yTop = mix(0.1, 0.9, t);
                float yBot = mix(0.9, 0.1, t);
                if (uvIcon.y > yBot && uvIcon.y < yTop) {
                    alphaIcon = 1.0;
                }
            }
        }
        if (alphaIcon > 0.0) {
            vec3 iconColor = vec3(1.0);
            color = mix(color, vec4(iconColor, 1.0), alphaIcon);
        }
    }

    imageStore(outImage, pixel, color);
}
