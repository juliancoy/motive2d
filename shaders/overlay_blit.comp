#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform image2D outImage;
layout(set = 0, binding = 1) uniform sampler2D texOverlay;
layout(set = 0, binding = 2) uniform sampler2D texFpsOverlay;

layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 videoSize;
    vec2 targetOrigin;
    vec2 targetSize;
    vec2 cropOrigin;
    vec2 cropSize;
    vec2 chromaDiv;
    uint colorSpace;
    uint colorRange;
    uint overlayEnabled;
    uint fpsOverlayEnabled;
    vec2 overlayOrigin;
    vec2 overlaySize;
    vec2 fpsOverlayOrigin;
    vec2 fpsOverlaySize;
    vec4 fpsOverlayBackground;
    float scrubProgress;
    float scrubPlaying;
    uint scrubberEnabled;
    uint padScrub0;
    uint padScrub1;
    uint padScrub2;
    vec4 grading;
    vec4 shadows;
    vec4 midtones;
    vec4 highlights;
} pushC;

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);
    vec4 color = imageLoad(outImage, pixel);

    if (pushC.overlayEnabled != 0u) {
        bool inOverlay = frag.x >= pushC.overlayOrigin.x &&
                         frag.y >= pushC.overlayOrigin.y &&
                         frag.x <= (pushC.overlayOrigin.x + pushC.overlaySize.x) &&
                         frag.y <= (pushC.overlayOrigin.y + pushC.overlaySize.y);
        if (inOverlay) {
            vec2 overlayUV = (frag - pushC.overlayOrigin) / pushC.overlaySize;
            vec4 overlaySample = texture(texOverlay, overlayUV);
            color = mix(color, overlaySample, overlaySample.a);
        }
    }

    if (pushC.fpsOverlayEnabled != 0u) {
        bool inFps = frag.x >= pushC.fpsOverlayOrigin.x &&
                     frag.y >= pushC.fpsOverlayOrigin.y &&
                     frag.x <= (pushC.fpsOverlayOrigin.x + pushC.fpsOverlaySize.x) &&
                     frag.y <= (pushC.fpsOverlayOrigin.y + pushC.fpsOverlaySize.y);
        if (inFps) {
            vec2 fpsUV = (frag - pushC.fpsOverlayOrigin) / pushC.fpsOverlaySize;
            vec4 fpsSample = texture(texFpsOverlay, fpsUV);
            if (fpsSample.a > 0.0) {
                vec4 bgColor = pushC.fpsOverlayBackground;
                if (bgColor.a > 0.0) {
                    float mixAlpha = bgColor.a * fpsSample.a;
                    color = mix(color, bgColor, mixAlpha);
                }
                color = mix(color, fpsSample, fpsSample.a);
            }
        }
    }

    imageStore(outImage, pixel, color);
}
